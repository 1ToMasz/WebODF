<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
  <style type="text/css">
/**/
   span { text-decoration: underline; color: blue; cursor: pointer; }
   pre { font-family: "Courier New", Courier, monospace; }
/**/</style>

<script type="text/javascript"><!--
function load_binary_resource(url) {  
  // this only works in firefox and arora, konqueror and opera do not load binary data
  var req = new XMLHttpRequest();  
  req.open('GET', url, false);  
  req.overrideMimeType('text/plain; charset=x-user-defined');  
  req.send(null);
  if (req.status != 200) {
    alert(req.status + " " + req.statusText);
    return '';
  }
  return req.responseText;  
}
function getHexCode(data, pos) {
  var val = (data[pos] & 0xff).toString(16);
  if (val.length == 1) {
    val = "0" + val;
  }
  return val;
}
function getPrintableCharacter(data, pos) {
  var val = data[pos] & 0xff;
  if (val >= 32 && val < 127) {
    val = String.fromCharCode(val);
  } else {
    val = '.';
  }
  return val;
}
function hexdump(data) {
  var bin = "";
  var hex = "";
  var txt = "";
  var length = data.length;
  for (var i=0; i<length; ++i) {
    if (i > 0 && i % 16 == 0) {
      var num = (i-16).toString(16);
      while (num.length < 8) {
        num = "0" + num;
      }
      bin = bin + num + "  " + hex + " |" + txt + "|\n";
      hex = "";
      txt = "";
    }
    hex = hex + getHexCode(data, i) + " ";
    txt = txt + getPrintableCharacter(data, i);
  }
  if (hex.length > 0) {
      var num = (i/16*16).toString(16);
      while (num.length < 8) {
        num = "0" + num;
      }
      while (hex.length < 3*16) {
        hex = hex + "   ";
      }
      bin = bin + num + "  " + hex + " |" + txt + "|\n";
  }

  var hexdump = document.getElementById('hexdump');
  clear(hexdump);
  var textNode = document.createTextNode(bin);
  hexdump.appendChild(textNode);
}

function clear(node) {
  while (node.firstChild) {
    node.removeChild(node.firstChild);
  }
}

var pptfiles = ['data/Important.ppt', 'data/b.ppt', 'data/charttest.ppt',
  'data/CI-3.ppt', 'data/CI-4.ppt', 'data/diagram.ppt', 'data/levels.ppt',
  'data/Presentation1.ppt', 'data/Presentation2.ppt', 'data/Presentation3.ppt', 'data/rectangle.ppt',
  'data/sd.ppt', 'data/simpleimageslide.ppt'];

function init() {
  var p = document.getElementById('filelist');
  for (var i = 0; i < pptfiles.length; i++) {
    addFile(p, pptfiles[i]);
  }
}

function addFile(p, file) {
  var span = document.createElement('span');
  p.appendChild(span);
  span.onclick = function() { listOleEntries(file); }
  span.appendChild(document.createTextNode(file));
  p.appendChild(document.createTextNode(' '));
}

/** helper function **/

function min(a, b) {
  return (a < b) ?a :b;
}

function max(a, b) {
  return (a < b) ?b :a;
}

function readLittleEndianInt32(data, offset) {
  var val = 0;
  val = data[offset]
   + (data[offset+1] << 8)
   + (data[offset+2] << 16)
   + (data[offset+3] << 24)
  return val;
}

/** StreamBuffer **/

var Ok = 0;
var Eof = 1;
var Error = 2;

function StreamBuffer() {
  this.start = new Array(32768);
  this.readPos = 0;
  this.size = this.start.length;
  this.avail = 0;
}

StreamBuffer.prototype.setSize = function(size) {
  this.start.length = size;
  this.size = size;
}

StreamBuffer.prototype.makeSpace = function(needed) {
  var space = this.size - this.readPos - this.avail;
  if (space >= needed) {
    return space;
  }
  if (this.avail) {
    if (this.readPos != 0) {
      this.start.splice(0, this.readPos);
      this.start.length = this.size;
      space = space + this.readPos;
      this.readPos = 0;
    }
  } else {
    this.readPos = 0;
    space = this.size;
  }
  if (space >= needed) {
    return space;
  }
  this.setSize(this.size + needed - space);
  return needed;
}

StreamBuffer.prototype.read = function(max) {
  if (max <= 0 || max > this.avail) {
    max = this.avail;
  }
  this.readPos += max;
  this.avail -= max;
  return this.start.slice(this.readPos-max, this.readPos);
}

/** BufferedInputStream **/

function BufferedInputStream() {
  this.buffer = new StreamBuffer();
  this.finishedWritingToBuffer = false;
}

BufferedInputStream.prototype.writeToBuffer = function(ntoread, maxread) {
  var missing = ntoread - this.buffer.avail;
  var nwritten = 0;
  while (missing > 0 && nwritten >= 0) {
    var space = this.buffer.makeSpace(missing);
    if (maxread >= ntoread && space > maxread) {
      space = maxread;
    }
    var start = this.buffer.readPos + this.buffer.avail;
    nwritten = this.fillBuffer(this.buffer.start, start, space);
    if (nwritten > 0) {
      this.buffer.avail += nwritten;
      missing = ntoread - this.buffer.avail;
    }
  }
  if (nwritten < 0) {
    this.finishedWritingToBuffer = true;
  }
}

BufferedInputStream.prototype.resetBuffer = function() {
  this.size = -1;
  this.position = -1;
  this.error = "";
  this.status = Ok;
  this.buffer.readPos = 0;
  this.buffer.avail = 0;
  this.finishedWritingToBuffer = false;
}

BufferedInputStream.prototype.setMinBufSize = function(size) {
  this.buffer.makeSpace(size);
}

BufferedInputStream.prototype.read = function(min, max) {
  if (this.status == Error) return undefined;
  if (this.status == Eof) return undefined;

  // do we need to read data into the buffer?
  if (min > max) max = 0;
  if (!this.finishedWritingToBuffer && min > this.buffer.avail) {
    // do we have enough space in the buffer?
    this.writeToBuffer(min, max);
    if (this.status == Error) {
      return undefined;
    }
  }

  var data = this.buffer.read(max);
  this.position += data.length;
  if (this.position > this.size && this.size > 0) {
    // error: we read more than was specified in size
    // this is an error because all dependent code might have been labouring
    // under a misapprehension
    this.status = Error;
    this.error = "Stream is longer than specified.";
    data = undefined;
  } else if (this.status == Ok && this.buffer.avail == 0
       && this.finishedWritingToBuffer) {
    this.status = Eof;
    if (this.size == -1) {
      this.size = this.position;
    }
    // save one call to read() by already returning -1 if no data is there
    if (data.length == 0) data = undefined;
  }
  return data;
}

BufferedInputStream.prototype.reset = function(pos) {
}

BufferedInputStream.prototype.skip = function(ntoskip) {
}

/** FileInputStream **/

function FileInputStream(fileurl) {
  // this is memory based
  var data = load_binary_resource(fileurl);
  this.data = new Array(data.length);
  var length = data.length;
  for (var i=0; i<length; ++i) {
    this.data[i] = data.charCodeAt(i) & 0xff;
  }
  this.pos = 0;
}

FileInputStream.prototype.read = function(min, max) {
  var navail = this.data.length - this.pos;
  if (navail <= 0) return undefined;
  var n = (max > min) ?max :min;
  n = (n <= navail) ?n :navail;
  this.pos += n;
  return this.data.slice(this.pos-n, this.pos);
}

FileInputStream.prototype.reset = function(pos) {
  this.pos = pos;
}

FileInputStream.prototype.size = function() {
  return this.data.length;
}

/** OleEntryStream **/

function OleEntryStream(parent) {
  this.parent = parent;
}
OleEntryStream.prototype = new BufferedInputStream();

OleEntryStream.prototype.reset = function() {
  this.resetBuffer();
  this.done = 0;
  this.blockoffset = 0;
  this.size = this.parent.currentStreamSize;
  this.blocksize = (this.size < 4096) ?64 : 512;
  this.pos = 0; //tmp var
}

OleEntryStream.prototype.fillBuffer = function(start, off, space) {
  if (this.done == this.size) return -1;

  var n = space;
  var avail = this.blocksize - this.blockoffset;
  if (avail > this.size - this.done) {
    avail = this.size - this.done;
  }
  if (n > avail) {
    n = avail;
  }
  var d;
  var offset;
  if (this.blocksize == 64) {
    d = this.parent.getCurrentSmallBlock();
    if (d == undefined) {
      this.status = Error;
      this.error = "error in small blocks";
      return -1;
    }
    offset = this.blockoffset;
  } else {
    d = this.parent.data;
    offset = (1+this.parent.currentDataBlock)*512 + this.blockoffset;
  }
  if (offset < 0 || this.parent.size < offset + n) {
    this.status = Error;
    this.error = "Invalid OLE stream.";
    return -1;
  }
  for (var i=0; i<n; ++i) {
    start[i+off] = d[i+offset];
  }
  //d = d.slice(offset, offset+n);
  this.done += n;
  this.blockoffset += n;
  if (this.blockoffset == this.blocksize) {
    if (this.blocksize == 64) {
      this.parent.currentDataBlock
        = this.parent.nextSmallBlock(this.parent.currentDataBlock);
    } else {
      this.parent.currentDataBlock
        = this.parent.nextBlock(this.parent.currentDataBlock);
    }
    this.blockoffset = 0;
    if (this.parent.currentDataBlock < 0) {
      if (this.parent.currentDataBlock != -2 || this.done != this.size) {
        this.error = "error at block " + this.parent.currentDataBlock;
        this.status = Error;
        n = -1;
      }
    }
  }
  return n;
}

/** OleInputStream **/

function OleInputStream(input) {
  this.currentTableBlock = -1;
  this.entryinfo = new Object();
  this.entrystream = new OleEntryStream(this);

  this.m_in = input;
  this.m_entryinfo = 1;
  this.data = input.read(512, 512);
  if (this.data.length != 512) {
    // error
    return;
  }
  this.m_in.reset(0);
  var nBat = readLittleEndianInt32(this.data, 0x2c);
  var ptOffset = readLittleEndianInt32(this.data, 0x30);
  var sBatOffset = readLittleEndianInt32(this.data, 0x3c);
  var xBatOffset = readLittleEndianInt32(this.data, 0x44);
  var nXBat = readLittleEndianInt32(this.data, 0x48);
  if (!this.checkHeader(this.data) || nBat < 0 || nBat > 128*nXBat+109
      || nXBat < 0) {
    // error
    return;
  }

  var maxp = 0;
  this.batIndex = new Array(nBat);
  this.data = this.data.slice(76);
  for (var i=0; i<min(109, nBat); ++i) {
    var p = readLittleEndianInt32(this.data, 4*i);
    this.batIndex[i] = p;
    maxp = max(p, maxp);
  }
  maxp = max(ptOffset, maxp);
  maxp = max(128*(nBat-1), maxp);

  var toread = (max+2)*512;
  if (input.size() >= 0 && input.size() < toread) {
    stream.status = Error;
    stream.error = "File is incomplete.";
    return;
  }
  toread = (input.size() > 0) ?input.size() :10000000;
  this.data = input.read(toread, toread);
  input.reset(0);
  if (this.data.length != input.size()) {
    stream.status = Error;
    stream.error = "File cannot be read completely: " + input.error;
    return;
  }
  maxindex = Math.floor(this.data.length/512)-2;

  // read any remaining BAT entries from XBAT blocks
  xBatOffset = 512 + 512 * xBatOffset;
  var n = 0;
  for (var j = 0; j < nXBat; ++j) {
      for (var i = 0; i<127 && this.batIndex.length < nBat; ++i) {
          var p = readLittleEndianInt32(this.data, 4*i + xBatOffset);
          this.batIndex[n++] = p;
      }
      xBatOffset = 512+512*readLittleEndianInt32(this.data, 508 + xBatOffset);
  }

  // collect all sbat blocks
  this.usedBlocks = new Object();
  this.usedSBlocks = new Object();
  this.sbatIndex = new Array();
  while (sBatOffset >= 0 && this.sbatIndex.length < 1000) {
    this.sbatIndex[this.sbatIndex.length] = sBatOffset;
    sBatOffset = this.nextBlock(sBatOffset);
  }

  // read the info for the root entry
  this.currentDataBlock = (1+ptOffset)*512 + 0x74;
  if (this.currentDataBlock + 4 > this.data.length) {
    //Error
    this.status = Error;
    this.error = "Invalid header.";
    return;
  }
  this.currentDataBlock = readLittleEndianInt32(this.data, this.currentDataBlock);
  this.sbatbIndex = new Array();
  while (this.currentDataBlock >= 0 && this.sbatbIndex.length < 16000) {
    this.sbatbIndex[this.sbatbIndex.length] = this.currentDataBlock;
    this.currentDataBlock = this.nextBlock(this.currentDataBlock);
  }
  this.maxsindex = this.sbatbIndex.length*8;

  this.currentTableBlock = ptOffset;
  this.currentTableIndex = 0;
}

OleInputStream.prototype.nextBlock = function(inp) {
  // get the number of the bat block we need
  var bid = Math.floor(inp/128);
  if (bid < 0 || bid >= this.batIndex.length) {
    alert("error 5: input block out of range " + inp);
    return -4;
  }
  bid = this.batIndex[bid]+1;
  var next = inp%128*4;
  next += 512*bid;
  if (next < 0 || this.data.length - 4 < next) {
    alert("error 3: output block out of range " + next);
    return -4;
  }
  bid = next;
  next = readLittleEndianInt32(this.data, bid);
  var error = next < -2 || next == -1 || next > this.maxindex
      || this.usedBlocks[next] == 1;
  if (error) {
    alert("error 4: output block out of range " + next);
    next = -4;
  } else if (next >= 0) {
    // mark block as read
    this.usedBlocks[next] = 1;
  }
  return next;
}

OleInputStream.prototype.nextSmallBlock = function(inp) {
  // get the number of the sbat block we need
  var bid = Math.floor(inp/128);
  if (bid < 0 || bid >= this.sbatIndex.length) {
    alert("error 6: input block out of range " + inp);
    return -4;
  }
  bid = this.sbatIndex[bid]+1;
  var next = inp%128*4;
  next += 512*bid;
  if (next < 0 || this.size - 4 < next) {
    alert("error 1: output block out of range " + next);
    return -4;
  }
  next = readLittleEndianInt32(this.data, next);
  var error = next < -2 || next == -1 || next > this.maxsindex
    || this.usedSBlocks[next] == 1;
  if (error) {
    alert("error 2: output block out of range " + next);
    next = -4;
  } else if (next >= 0) {
    // mark block as read
    this.usedSBlocks[next] = 1;
  }
  return next;
}

OleInputStream.prototype.getCurrentSmallBlock = function() {
  var i = Math.floor(this.currentDataBlock/8);
  if (i < 0 || i >= this.sbatbIndex.length) {
    return undefined;
  }
  i = 512*(1+this.sbatbIndex[i]) + (this.currentDataBlock%8)*64;
  return (i > this.size-64) ?undefined :this.data.slice(i, i+64);
}

OleInputStream.prototype.checkHeader = function(data) {
  var ole_magic = [0xd0, 0xcf, 0x11, 0xe0, 0xa1, 0xb1, 0x1a, 0xe1];
  for (var i=0; i<ole_magic.length; ++i) {
    if (data[i] != ole_magic[i]) return false;
  }
  return true;
}

OleInputStream.prototype.nextEntry = function() {
  if (this.currentTableBlock < 0) return undefined;
  do {
    if (++this.currentTableIndex == 4) {
      this.currentTableBlock = this.nextBlock(this.currentTableBlock);
      if (this.currentTableBlock < 0) {
        return undefined;
      }
      this.currentTableIndex = 0;
    }
    this.readEntryInfo();
  } while (this.currentDataBlock < 0);

  this.entrystream.reset();

  return this.entrystream;
}

OleInputStream.prototype.readEntryInfo = function() {
  var d = this.data.slice(
      (1+this.currentTableBlock)*512 + 128*this.currentTableIndex);
  var entryType = d[0x42];
  if (entryType != 2) {
    this.currentDataBlock = -1;
    return;
  }
  var name = "";
  var namesize = d[0x40];
  if (namesize < 2) namesize = 2;
  if (namesize > 0x40) namesize = 0x40;
  namesize = Math.floor(namesize/2) - 1;
  var badname = false;
  for (var i=0; i < namesize; ++i) {
    badname = badname || d[2*i+1];
    name = name + String.fromCharCode(d[2*i]);
  }
  if (badname) {
    name = "";
  }

  this.entryinfo.filename = name;
  this.currentDataBlock = readLittleEndianInt32(d, 0x74);
  this.currentStreamSize = readLittleEndianInt32(d, 0x78);
  this.entryinfo.size = this.currentStreamSize;
  if (this.currentDataBlock > this.maxindex || this.currentStreamSize <= 0) {
    this.currentDataBlock = -1;
  }
}

OleInputStream.prototype.entryInfo = function() {
  return this.m_entryinfo;
}

function appendOleEntry(p, data, name, length) {
  var span = document.createElement("span");
  span.appendChild(document.createTextNode(name));
  span.onclick = function() { hexdump(data); }
  p.appendChild(span);
  p.appendChild(document.createTextNode(" " + length + " " + data.length));
  p.appendChild(document.createElement("br"));
}

function listOleEntries(fileurl) {
  var p = document.getElementById('listing');
  clear(p);
  clear(document.getElementById('hexdump'));
  var cin = new FileInputStream(fileurl);
  var ole = new OleInputStream(cin);
  var entry = ole.nextEntry();
  while (undefined != entry) {
    var data = entry.read(1, 0);
    var n = new Array(ole.entryinfo.size);
    var i = 0;
    while (data != undefined && data.length > 0) {
      var length = data.length;
      for (var j=0; j<length; ++j) {
        n[i+j] = data[j];
      }
      i += data.length;
      data = entry.read(1, 0);
    }
    appendOleEntry(p, n, ole.entryinfo.filename, ole.entryinfo.size);
    entry = ole.nextEntry();
  }
}

--></script>
 </head>
<body onload='init()'>
<p id='filelist'>
</p>
<pre id="listing"></pre>
<pre id="hexdump"></pre>
</body>
</html>
